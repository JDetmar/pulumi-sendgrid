// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sendgrid

import (
	"context"
	"reflect"

	"errors"
	"github.com/JDetmar/pulumi-sendgrid/sdk/go/sendgrid/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a SendGrid IP Pool.
//
// IP Pools allow you to group your dedicated SendGrid IP addresses together. For example, you might have separate pools for transactional and marketing emails, so that each pool maintains its own reputation.
//
// Note: Each account can create up to 100 IP pools. IP pools can only be used with IP addresses that have reverse DNS configured.
type IpPool struct {
	pulumi.CustomResourceState

	Ips      pulumi.StringArrayOutput `pulumi:"ips"`
	Name     pulumi.StringOutput      `pulumi:"name"`
	PoolName pulumi.StringOutput      `pulumi:"poolName"`
}

// NewIpPool registers a new resource with the given unique name, arguments, and options.
func NewIpPool(ctx *pulumi.Context,
	name string, args *IpPoolArgs, opts ...pulumi.ResourceOption) (*IpPool, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource IpPool
	err := ctx.RegisterResource("sendgrid:index:IpPool", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIpPool gets an existing IpPool resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIpPool(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IpPoolState, opts ...pulumi.ResourceOption) (*IpPool, error) {
	var resource IpPool
	err := ctx.ReadResource("sendgrid:index:IpPool", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IpPool resources.
type ipPoolState struct {
}

type IpPoolState struct {
}

func (IpPoolState) ElementType() reflect.Type {
	return reflect.TypeOf((*ipPoolState)(nil)).Elem()
}

type ipPoolArgs struct {
	Name string `pulumi:"name"`
}

// The set of arguments for constructing a IpPool resource.
type IpPoolArgs struct {
	Name pulumi.StringInput
}

func (IpPoolArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ipPoolArgs)(nil)).Elem()
}

type IpPoolInput interface {
	pulumi.Input

	ToIpPoolOutput() IpPoolOutput
	ToIpPoolOutputWithContext(ctx context.Context) IpPoolOutput
}

func (*IpPool) ElementType() reflect.Type {
	return reflect.TypeOf((**IpPool)(nil)).Elem()
}

func (i *IpPool) ToIpPoolOutput() IpPoolOutput {
	return i.ToIpPoolOutputWithContext(context.Background())
}

func (i *IpPool) ToIpPoolOutputWithContext(ctx context.Context) IpPoolOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpPoolOutput)
}

// IpPoolArrayInput is an input type that accepts IpPoolArray and IpPoolArrayOutput values.
// You can construct a concrete instance of `IpPoolArrayInput` via:
//
//	IpPoolArray{ IpPoolArgs{...} }
type IpPoolArrayInput interface {
	pulumi.Input

	ToIpPoolArrayOutput() IpPoolArrayOutput
	ToIpPoolArrayOutputWithContext(context.Context) IpPoolArrayOutput
}

type IpPoolArray []IpPoolInput

func (IpPoolArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpPool)(nil)).Elem()
}

func (i IpPoolArray) ToIpPoolArrayOutput() IpPoolArrayOutput {
	return i.ToIpPoolArrayOutputWithContext(context.Background())
}

func (i IpPoolArray) ToIpPoolArrayOutputWithContext(ctx context.Context) IpPoolArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpPoolArrayOutput)
}

// IpPoolMapInput is an input type that accepts IpPoolMap and IpPoolMapOutput values.
// You can construct a concrete instance of `IpPoolMapInput` via:
//
//	IpPoolMap{ "key": IpPoolArgs{...} }
type IpPoolMapInput interface {
	pulumi.Input

	ToIpPoolMapOutput() IpPoolMapOutput
	ToIpPoolMapOutputWithContext(context.Context) IpPoolMapOutput
}

type IpPoolMap map[string]IpPoolInput

func (IpPoolMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpPool)(nil)).Elem()
}

func (i IpPoolMap) ToIpPoolMapOutput() IpPoolMapOutput {
	return i.ToIpPoolMapOutputWithContext(context.Background())
}

func (i IpPoolMap) ToIpPoolMapOutputWithContext(ctx context.Context) IpPoolMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpPoolMapOutput)
}

type IpPoolOutput struct{ *pulumi.OutputState }

func (IpPoolOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IpPool)(nil)).Elem()
}

func (o IpPoolOutput) ToIpPoolOutput() IpPoolOutput {
	return o
}

func (o IpPoolOutput) ToIpPoolOutputWithContext(ctx context.Context) IpPoolOutput {
	return o
}

func (o IpPoolOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IpPool) pulumi.StringArrayOutput { return v.Ips }).(pulumi.StringArrayOutput)
}

func (o IpPoolOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *IpPool) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o IpPoolOutput) PoolName() pulumi.StringOutput {
	return o.ApplyT(func(v *IpPool) pulumi.StringOutput { return v.PoolName }).(pulumi.StringOutput)
}

type IpPoolArrayOutput struct{ *pulumi.OutputState }

func (IpPoolArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpPool)(nil)).Elem()
}

func (o IpPoolArrayOutput) ToIpPoolArrayOutput() IpPoolArrayOutput {
	return o
}

func (o IpPoolArrayOutput) ToIpPoolArrayOutputWithContext(ctx context.Context) IpPoolArrayOutput {
	return o
}

func (o IpPoolArrayOutput) Index(i pulumi.IntInput) IpPoolOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IpPool {
		return vs[0].([]*IpPool)[vs[1].(int)]
	}).(IpPoolOutput)
}

type IpPoolMapOutput struct{ *pulumi.OutputState }

func (IpPoolMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpPool)(nil)).Elem()
}

func (o IpPoolMapOutput) ToIpPoolMapOutput() IpPoolMapOutput {
	return o
}

func (o IpPoolMapOutput) ToIpPoolMapOutputWithContext(ctx context.Context) IpPoolMapOutput {
	return o
}

func (o IpPoolMapOutput) MapIndex(k pulumi.StringInput) IpPoolOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IpPool {
		return vs[0].(map[string]*IpPool)[vs[1].(string)]
	}).(IpPoolOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IpPoolInput)(nil)).Elem(), &IpPool{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpPoolArrayInput)(nil)).Elem(), IpPoolArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpPoolMapInput)(nil)).Elem(), IpPoolMap{})
	pulumi.RegisterOutputType(IpPoolOutput{})
	pulumi.RegisterOutputType(IpPoolArrayOutput{})
	pulumi.RegisterOutputType(IpPoolMapOutput{})
}
